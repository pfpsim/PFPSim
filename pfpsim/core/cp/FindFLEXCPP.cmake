#.rst:
# FindFLEX
# --------
#
# Find flex executable and provides a macro to generate custom build rules
#
#
#
# The module defines the following variables:
#
# ::
#
#   FLEXCPP_FOUND - true is flex executable is found
#   FLEXCPP_EXECUTABLE - the path to the flex executable
#   FLEXCPP_VERSION - the version of flex
#   FLEXCPP_LIBRARIES - The flex libraries
#   FLEXCPP_INCLUDE_DIRS - The path to the flex headers
#
#
#
# The minimum required version of flex can be specified using the
# standard syntax, e.g.  find_package(FLEXCPP 2.5.13)
#
#
#
# If flex is found on the system, the module provides the macro:
#
# ::
#
#   FLEXCPP_TARGET(Name FlexInput FlexOutput
#               [COMPILE_FLAGS <string>]
#               )
#
# which creates a custom command to generate the <FlexOutput> file from
# the <FlexInput> file.  If COMPILE_FLAGS option is specified, the next
# parameter is added to the flex command line. If flex is configured to
# output a header file, the DEFINES_FILE option may be used to specify its
# name. Name is an alias used to get details of this custom command.
# Indeed the macro defines the following variables:
#
# ::
#
#   FLEXCPP_${Name}_DEFINED - true is the macro ran successfully
#   FLEXCPP_${Name}_OUTPUTS - the source file generated by the custom rule, an
#   alias for FlexOutput
#   FLEXCPP_${Name}_INPUT - the flex source file, an alias for ${FlexInput}
#   FLEXCPP_${Name}_OUTPUT_HEADER - the header flex output, if any.
#
#
#
# Flex scanners oftenly use tokens defined by Bison: the code generated
# by Flex depends of the header generated by Bison.  This module also
# defines a macro:
#
# ::
#
#   ADD_FLEXCPP_BISONCPP_DEPENDENCY(FlexTarget BisonTarget)
#
# which adds the required dependency between a scanner and a parser
# where <FlexTarget> and <BisonTarget> are the first parameters of
# respectively FLEXCPP_TARGET and BISONCPP_TARGET macros.
#
# ::
#
#   ====================================================================
#   Example:
#
#
#
# ::
#
#    find_package(BISON)
#    find_package(FLEX)
#
#
#
# ::
#
#    BISONCPP_TARGET(MyParser parser.y ${CMAKE_CURRENT_BINARY_DIR}/parser.cpp)
#    FLEXCPP_TARGET(MyScanner lexer.l  ${CMAKE_CURRENT_BINARY_DIR}/lexer.cpp)
#    ADD_FLEXCPP_BISONCPP_DEPENDENCY(MyScanner MyParser)
#
#
#
# ::
#
#    include_directories(${CMAKE_CURRENT_BINARY_DIR})
#    add_executable(Foo
#       Foo.cc
#       ${BISONCPP_MyParser_OUTPUTS}
#       ${FLEXCPP_MyScanner_OUTPUTS}
#    )
#   ====================================================================

#=============================================================================
# Copyright 2009 Kitware, Inc.
# Copyright 2006 Tristan Carel
#
# Distributed under the OSI-approved BSD License (the "License");
# see accompanying file Copyright.txt for details.
#
# This software is distributed WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the License for more information.
#=============================================================================
# (To distribute this file outside of CMake, substitute the full
#  License text for the above reference.)

find_program(FLEXCPP_EXECUTABLE NAMES flexc++ DOC "path to the flex executable")
mark_as_advanced(FLEXCPP_EXECUTABLE)

find_library(FL_LIBRARY NAMES fl
  DOC "Path to the fl library")

find_path(FLEXCPP_INCLUDE_DIR FlexLexer.h
  DOC "Path to the flex headers")

mark_as_advanced(FL_LIBRARY FLEXCPP_INCLUDE_DIR)

include(CMakeParseArguments)

set(FLEXCPP_INCLUDE_DIRS ${FLEXCPP_INCLUDE_DIR})
set(FLEXCPP_LIBRARIES ${FL_LIBRARY})

if(FLEXCPP_EXECUTABLE)

  execute_process(COMMAND ${FLEXCPP_EXECUTABLE} --version
    OUTPUT_VARIABLE FLEXCPP_version_output
    ERROR_VARIABLE FLEXCPP_version_error
    RESULT_VARIABLE FLEXCPP_version_result
    OUTPUT_STRIP_TRAILING_WHITESPACE)
  if(NOT ${FLEXCPP_version_result} EQUAL 0)
    message(SEND_ERROR "Command \"${FLEXCPP_EXECUTABLE} --version\" failed with output:\n${FLEXCPP_version_error}")
  else()
    if("${FLEXCPP_version_output}" MATCHES "^flexc\\+\\+ V([^,]+)")
      set(FLEXCPP_VERSION "${CMAKE_MATCH_1}")
    endif()
  endif()

  #============================================================
  # FLEXCPP_TARGET (public macro)
  #============================================================
  #
  macro(FLEXCPP_TARGET Name Input Output Classname)
    set(FLEXCPP_TARGET_outputs "${CMAKE_CURRENT_SOURCE_DIR}/${Output}")
    set(FLEXCPP_EXECUTABLE_opts "")

    set(FLEXCPP_TARGET_PARAM_OPTIONS)
    set(FLEXCPP_TARGET_PARAM_ONE_VALUE_KEYWORDS
      COMPILE_FLAGS
      )
    set(FLEXCPP_TARGET_PARAM_MULTI_VALUE_KEYWORDS)

    cmake_parse_arguments(
      FLEXCPP_TARGET_ARG
      "${FLEXCPP_TARGET_PARAM_OPTIONS}"
      "${FLEXCPP_TARGET_PARAM_ONE_VALUE_KEYWORDS}"
      "${FLEXCPP_TARGET_MULTI_VALUE_KEYWORDS}"
      ${ARGN}
      )

    set(FLEXCPP_TARGET_usage "FLEXCPP_TARGET(<Name> <Input> <Output> <Classname> [COMPILE_FLAGS <string>]")

    if(NOT "${FLEXCPP_TARGET_ARG_UNPARSED_ARGUMENTS}" STREQUAL "")
      message(SEND_ERROR ${FLEXCPP_TARGET_usage})
    else()
      if(NOT "${FLEXCPP_TARGET_ARG_COMPILE_FLAGS}" STREQUAL "")
        set(FLEXCPP_EXECUTABLE_opts "${FLEXCPP_TARGET_ARG_COMPILE_FLAGS}")
        separate_arguments(FLEXCPP_EXECUTABLE_opts)
      endif()

      set(FLEXCPP_OUTPUT_HEADER "${CMAKE_CURRENT_SOURCE_DIR}/${Classname}base.h")
      list(APPEND FLEXCPP_TARGET_outputs "${FLEXCPP_OUTPUT_HEADER}")

      add_custom_command(OUTPUT ${FLEXCPP_TARGET_outputs}
        COMMAND ${FLEXCPP_EXECUTABLE}
        ARGS ${FLEXCPP_EXECUTABLE_opts} --no-lines --lex-source=${Output} --class-name=${Classname} ${Input}
        DEPENDS ${Input}
        COMMENT "[FLEXC++][${Name}] Building scanner with flexc++ ${FLEXCPP_VERSION}"
        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})


      set(FLEXCPP_${Name}_DEFINED TRUE)
      set(FLEXCPP_${Name}_OUTPUTS ${FLEXCPP_TARGET_outputs})
      set(FLEXCPP_${Name}_INPUT ${Input})
      set(FLEXCPP_${Name}_COMPILE_FLAGS ${FLEXCPP_EXECUTABLE_opts})
      set(FLEXCPP_${Name}_OUTPUT_HEADER "${FLEXCPP_OUTPUT_HEADER}")
    endif()
  endmacro()
  #============================================================


  #============================================================
  # ADD_FLEXCPP_BISONCPP_DEPENDENCY (public macro)
  #============================================================
  #
  macro(ADD_FLEXCPP_BISONCPP_DEPENDENCY FlexTarget BisonTarget)

    if(NOT FLEXCPP_${FlexTarget}_OUTPUTS)
      message(SEND_ERROR "Flex target `${FlexTarget}' does not exist.")
    endif()

    if(NOT BISONCPP_${BisonTarget}_OUTPUT_HEADER)
      message(SEND_ERROR "Bison target `${BisonTarget}' does not exist.")
    endif()

    set_source_files_properties(${FLEXCPP_${FlexTarget}_OUTPUTS}
      PROPERTIES OBJECT_DEPENDS ${BISONCPP_${BisonTarget}_OUTPUT_HEADER})
  endmacro()
  #============================================================

endif()

find_package(PackageHandleStandardArgs)
FIND_PACKAGE_HANDLE_STANDARD_ARGS(FLEXCPP REQUIRED_VARS FLEXCPP_EXECUTABLE
                                       VERSION_VAR FLEXCPP_VERSION)

# FindFLEX.cmake ends here
