/*
 * PFPSim: Library for the Programmable Forwarding Plane Simulation Framework
 *
 * Copyright (C) 2016 Concordia Univ., Montreal
 *     Samar Abdi
 *     Umair Aftab
 *     Gordon Bailey
 *     Faras Dewal
 *     Shafigh Parsazad
 *     Eric Tremblay
 *
 * Copyright (C) 2016 Ericsson
 *     Bochra Boughzala
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

// Generated by Flexc++ V2.01.00 on Sun, 03 Apr 2016 08:35:18 -0400

#ifndef CORE_CP_COMMANDSCANNER_H_
#define CORE_CP_COMMANDSCANNER_H_
#include <string>

#ifndef pfp_cpCommandScannerBase_h_included
#include "NAMESPACE_HACK_BEGIN"
// $insert baseclass_h
#include "CommandScannerbase.h"
#include "NAMESPACE_HACK_END"
#endif

#ifndef pfp_cpCommandParserBase_h_included
#include "NAMESPACE_HACK_BEGIN"  // NOLINT(build/include)
#include "CommandParserbase.h"
#include "NAMESPACE_HACK_END"  // NOLINT(build/include)
#endif

// #define SCANNER_DEBUG 1

#include "NAMESPACE_HACK_BEGIN"  // NOLINT(build/include)
// $insert namespace-open
namespace pfp_cp {

// $insert classHead
class CommandScanner: public CommandScannerBase {
 public:
  explicit CommandScanner(std::istream &in = std::cin,
                          std::ostream &out = std::cout);

  CommandScanner(std::string const &infile, std::string const &outfile);

  // $insert lexFunctionDecl
  int lex();
  // See https://fbb-git.github.io/bisoncpp/manual/bisonc++06.html#DVAL
  void setSval(Meta__::SType *);

 private:
  Meta__::SType * val;

  template <typename T>
  void returnValue(T);

 private:
  int lex__();
  int executeAction__(size_t ruleNr);

  void print();
  void preCode();     // re-implement this function for code that must
                      // be exec'ed before the patternmatching starts

  void postCode(PostEnum__ type);
                      // re-implement this function for code that must
                      // be exec'ed after the rules's actions.
};

#ifdef SCANNER_DEBUG
  #define returnToken(symbol) do { \
    std::cout << #symbol << std::endl; \
    return Parser::symbol;\
  } while (0)
#else
  #define returnToken(symbol) return CommandParser::symbol
#endif

template <typename T>
void CommandScanner::returnValue(T t) {
  val->get< Meta__::TagOf<T>::tag  >() = t;
}

inline void CommandScanner::setSval(Meta__::SType * sval) {
  val = sval;
}

// $insert scannerConstructors
inline CommandScanner::CommandScanner(std::istream &in, std::ostream &out)
:
    CommandScannerBase(in, out)
{}

inline CommandScanner::CommandScanner(std::string const &infile,
      std::string const &outfile): CommandScannerBase(infile, outfile) {}

// $insert inlineLexFunction
inline int CommandScanner::lex() {
    return lex__();
}

inline void CommandScanner::preCode() {
    // optionally replace by your own code
}

inline void CommandScanner::postCode(PostEnum__ type) {
    // optionally replace by your own code
}

inline void CommandScanner::print() {
    print__();
}

// $insert namespace-close
};  // namespace pfp_cp
#include "NAMESPACE_HACK_END"  // NOLINT(build/include)

#endif  // CORE_CP_COMMANDSCANNER_H_
